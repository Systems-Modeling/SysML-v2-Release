{"version":3,"sources":["../src/index.ts","../../../node_modules/tslib/tslib.es6.js"],"names":["Private","Application","options","this","_started","_pluginMap","createPluginMap","_serviceMap","createServiceMap","_delegate","PromiseDelegate","commands","CommandRegistry","renderer","contextMenuRenderer","contextMenu","ContextMenu","commands$1","shell","Object","defineProperty","prototype","promise","hasPlugin","id","listPlugins","keys","registerPlugin","plugin","Error","data","createPluginData","ensureNoCycle","provides","set","registerPlugins","plugins","_i","plugins_1","length","activatePlugin","_this","Promise","reject","activated","resolve","undefined","required","requires","map","t","resolveRequiredService","optional","resolveOptionalService","promises","concat","all","then","services","activate","apply","s","i","il","arguments","r","Array","k","a","j","jl","__spreadArrays","service","catch","error","token","get","name","reason","console","start","hostID","collectStartupPlugins","attachShell","addEventListeners","handleEvent","event","type","evtResize","evtKeydown","evtContextMenu","Widget","attach","document","getElementById","body","addEventListener","window","processKeydownEvent","shiftKey","open","preventDefault","stopPropagation","update","create","Map","autoStart","slice","pluginMap","serviceMap","dependencies","trace","some","visit","other","otherDependencies","push","pop","join","resultMap","startPlugins","_a","ignorePlugins","_b","_c"],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  CommandRegistry\n} from '@lumino/commands';\n\nimport {\n  PromiseDelegate, Token\n} from '@lumino/coreutils';\n\nimport {\n  ContextMenu, Menu, Widget\n} from '@lumino/widgets';\n\n\n/**\n * A user-defined application plugin.\n *\n * #### Notes\n * Plugins are the foundation for building an extensible application.\n *\n * Plugins consume and provide \"services\", which are nothing more than\n * concrete implementations of interfaces and/or abstract types.\n *\n * Unlike regular imports and exports, which tie the service consumer\n * to a particular implementation of the service, plugins decouple the\n * service producer from the service consumer, allowing an application\n * to be easily customized by third parties in a type-safe fashion.\n */\nexport\ninterface IPlugin<T, U> {\n  /**\n   * The human readable id of the plugin.\n   *\n   * #### Notes\n   * This must be unique within an application.\n   */\n  id: string;\n\n  /**\n   * Whether the plugin should be activated on application start.\n   *\n   * #### Notes\n   * The default is `false`.\n   */\n  autoStart?: boolean;\n\n  /**\n   * The types of required services for the plugin, if any.\n   *\n   * #### Notes\n   * These tokens correspond to the services that are required by\n   * the plugin for correct operation.\n   *\n   * When the plugin is activated, a concrete instance of each type\n   * will be passed to the `activate()` function, in the order they\n   * are specified in the `requires` array.\n   */\n  requires?: Token<any>[];\n\n  /**\n   * The types of optional services for the plugin, if any.\n   *\n   * #### Notes\n   * These tokens correspond to the services that can be used by the\n   * plugin if available, but are not necessarily required.\n   *\n   * The optional services will be passed to the `activate()` function\n   * following all required services. If an optional service cannot be\n   * resolved, `null` will be passed in its place.\n   */\n  optional?: Token<any>[];\n\n  /**\n   * The type of service provided by the plugin, if any.\n   *\n   * #### Notes\n   * This token corresponds to the service exported by the plugin.\n   *\n   * When the plugin is activated, the return value of `activate()`\n   * is used as the concrete instance of the type.\n   */\n  provides?: Token<U>;\n\n  /**\n   * A function invoked to activate the plugin.\n   *\n   * @param app - The application which owns the plugin.\n   *\n   * @param args - The services specified by the `requires` property.\n   *\n   * @returns The provided service, or a promise to the service.\n   *\n   * #### Notes\n   * This function will be called whenever the plugin is manually\n   * activated, or when another plugin being activated requires\n   * the service it provides.\n   *\n   * This function will not be called unless all of its required\n   * services can be fulfilled.\n   */\n  activate: (app: T, ...args: any[]) => U | Promise<U>;\n}\n\n\n/**\n * A class for creating pluggable applications.\n *\n * #### Notes\n * The `Application` class is useful when creating large, complex\n * UI applications with the ability to be safely extended by third\n * party code via plugins.\n */\nexport\nclass Application<T extends Widget> {\n  /**\n   * Construct a new application.\n   *\n   * @param options - The options for creating the application.\n   */\n  constructor(options: Application.IOptions<T>) {\n    // Create the application command registry.\n    let commands = new CommandRegistry();\n\n    // Create the application context menu.\n    let renderer = options.contextMenuRenderer;\n    let contextMenu = new ContextMenu({ commands, renderer });\n\n    // Initialize the application state.\n    this.commands = commands;\n    this.contextMenu = contextMenu;\n    this.shell = options.shell;\n  }\n\n  /**\n   * The application command registry.\n   */\n  readonly commands: CommandRegistry;\n\n  /**\n   * The application context menu.\n   */\n  readonly contextMenu: ContextMenu;\n\n  /**\n   * The application shell widget.\n   *\n   * #### Notes\n   * The shell widget is the root \"container\" widget for the entire\n   * application. It will typically expose an API which allows the\n   * application plugins to insert content in a variety of places.\n   */\n  readonly shell: T;\n\n  /**\n   * A promise which resolves after the application has started.\n   *\n   * #### Notes\n   * This promise will resolve after the `start()` method is called,\n   * when all the bootstrapping and shell mounting work is complete.\n   */\n  get started(): Promise<void> {\n    return this._delegate.promise;\n  }\n\n  /**\n   * Test whether a plugin is registered with the application.\n   *\n   * @param id - The id of the plugin of interest.\n   *\n   * @returns `true` if the plugin is registered, `false` otherwise.\n   */\n  hasPlugin(id: string): boolean {\n    return id in this._pluginMap;\n  }\n\n  /**\n   * List the IDs of the plugins registered with the application.\n   *\n   * @returns A new array of the registered plugin IDs.\n   */\n  listPlugins(): string[] {\n    return Object.keys(this._pluginMap);\n  }\n\n  /**\n   * Register a plugin with the application.\n   *\n   * @param plugin - The plugin to register.\n   *\n   * #### Notes\n   * An error will be thrown if a plugin with the same id is already\n   * registered, or if the plugin has a circular dependency.\n   *\n   * If the plugin provides a service which has already been provided\n   * by another plugin, the new service will override the old service.\n   */\n  registerPlugin(plugin: IPlugin<this, any>): void {\n    // Throw an error if the plugin id is already registered.\n    if (plugin.id in this._pluginMap) {\n      throw new Error(`Plugin '${plugin.id}' is already registered.`);\n    }\n\n    // Create the normalized plugin data.\n    let data = Private.createPluginData(plugin);\n\n    // Ensure the plugin does not cause a cyclic dependency.\n    Private.ensureNoCycle(data, this._pluginMap, this._serviceMap);\n\n    // Add the service token to the service map.\n    if (data.provides) {\n      this._serviceMap.set(data.provides, data.id);\n    }\n\n    // Add the plugin to the plugin map.\n    this._pluginMap[data.id] = data;\n  }\n\n  /**\n   * Register multiple plugins with the application.\n   *\n   * @param plugins - The plugins to register.\n   *\n   * #### Notes\n   * This calls `registerPlugin()` for each of the given plugins.\n   */\n  registerPlugins(plugins: IPlugin<this, any>[]): void {\n    for (let plugin of plugins) {\n      this.registerPlugin(plugin);\n    }\n  }\n\n  /**\n   * Activate the plugin with the given id.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns A promise which resolves when the plugin is activated\n   *   or rejects with an error if it cannot be activated.\n   */\n  activatePlugin(id: string): Promise<void> {\n    // Reject the promise if the plugin is not registered.\n    let data = this._pluginMap[id];\n    if (!data) {\n      return Promise.reject(new Error(`Plugin '${id}' is not registered.`));\n    }\n\n    // Resolve immediately if the plugin is already activated.\n    if (data.activated) {\n      return Promise.resolve(undefined);\n    }\n\n    // Return the pending resolver promise if it exists.\n    if (data.promise) {\n      return data.promise;\n    }\n\n    // Resolve the required services for the plugin.\n    let required = data.requires.map(t => this.resolveRequiredService(t));\n\n    // Resolve the optional services for the plugin.\n    let optional = data.optional.map(t => this.resolveOptionalService(t));\n\n    // Create the array of promises to resolve.\n    let promises = required.concat(optional);\n\n    // Setup the resolver promise for the plugin.\n    data.promise = Promise.all(promises).then(services => {\n      return data.activate.apply(undefined, [this, ...services]);\n    }).then(service => {\n      data.service = service;\n      data.activated = true;\n      data.promise = null;\n    }).catch(error => {\n      data.promise = null;\n      throw error;\n    });\n\n    // Return the pending resolver promise.\n    return data.promise;\n  }\n\n  /**\n   * Resolve a required service of a given type.\n   *\n   * @param token - The token for the service type of interest.\n   *\n   * @returns A promise which resolves to an instance of the requested\n   *   service, or rejects with an error if it cannot be resolved.\n   *\n   * #### Notes\n   * Services are singletons. The same instance will be returned each\n   * time a given service token is resolved.\n   *\n   * If the plugin which provides the service has not been activated,\n   * resolving the service will automatically activate the plugin.\n   *\n   * User code will not typically call this method directly. Instead,\n   * the required services for the user's plugins will be resolved\n   * automatically when the plugin is activated.\n   */\n  resolveRequiredService<U>(token: Token<U>): Promise<U> {\n    // Reject the promise if there is no provider for the type.\n    let id = this._serviceMap.get(token);\n    if (!id) {\n      return Promise.reject(new Error(`No provider for: ${token.name}.`));\n    }\n\n    // Resolve immediately if the plugin is already activated.\n    let data = this._pluginMap[id];\n    if (data.activated) {\n      return Promise.resolve(data.service);\n    }\n\n    // Otherwise, activate the plugin and wait on the results.\n    return this.activatePlugin(id).then(() => data.service);\n  }\n\n  /**\n   * Resolve an optional service of a given type.\n   *\n   * @param token - The token for the service type of interest.\n   *\n   * @returns A promise which resolves to an instance of the requested\n   *   service, or `null` if it cannot be resolved.\n   *\n   * #### Notes\n   * Services are singletons. The same instance will be returned each\n   * time a given service token is resolved.\n   *\n   * If the plugin which provides the service has not been activated,\n   * resolving the service will automatically activate the plugin.\n   *\n   * User code will not typically call this method directly. Instead,\n   * the optional services for the user's plugins will be resolved\n   * automatically when the plugin is activated.\n   */\n  resolveOptionalService<U>(token: Token<U>): Promise<U | null> {\n    // Resolve with `null` if there is no provider for the type.\n    let id = this._serviceMap.get(token);\n    if (!id) {\n      return Promise.resolve(null);\n    }\n\n    // Resolve immediately if the plugin is already activated.\n    let data = this._pluginMap[id];\n    if (data.activated) {\n      return Promise.resolve(data.service);\n    }\n\n    // Otherwise, activate the plugin and wait on the results.\n    return this.activatePlugin(id).then(() => {\n      return data.service;\n    }).catch(reason => {\n      console.error(reason);\n      return null;\n    });\n  }\n\n  /**\n   * Start the application.\n   *\n   * @param options - The options for starting the application.\n   *\n   * @returns A promise which resolves when all bootstrapping work\n   *   is complete and the shell is mounted to the DOM.\n   *\n   * #### Notes\n   * This should be called once by the application creator after all\n   * initial plugins have been registered.\n   *\n   * If a plugin fails to the load, the error will be logged and the\n   * other valid plugins will continue to be loaded.\n   *\n   * Bootstrapping the application consists of the following steps:\n   * 1. Activate the startup plugins\n   * 2. Wait for those plugins to activate\n   * 3. Attach the shell widget to the DOM\n   * 4. Add the application event listeners\n   */\n  start(options: Application.IStartOptions = {}): Promise<void> {\n    // Return immediately if the application is already started.\n    if (this._started) {\n      return this._delegate.promise;\n    }\n\n    // Mark the application as started;\n    this._started = true;\n\n    // Parse the host id for attaching the shell.\n    let hostID = options.hostID || '';\n\n    // Collect the ids of the startup plugins.\n    let startups = Private.collectStartupPlugins(this._pluginMap, options);\n\n    // Generate the activation promises.\n    let promises = startups.map(id => {\n      return this.activatePlugin(id).catch(error => {\n        console.error(`Plugin '${id}' failed to activate.`);\n        console.error(error);\n      });\n    });\n\n    // Wait for the plugins to activate, then finalize startup.\n    Promise.all(promises).then(() => {\n      this.attachShell(hostID);\n      this.addEventListeners();\n      this._delegate.resolve(undefined);\n    });\n\n    // Return the pending delegate promise.\n    return this._delegate.promise;\n  }\n\n  /**\n   * Handle the DOM events for the application.\n   *\n   * @param event - The DOM event sent to the application.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events registered for the application. It\n   * should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n    case 'resize':\n      this.evtResize(event);\n      break;\n    case 'keydown':\n      this.evtKeydown(event as KeyboardEvent);\n      break;\n    case 'contextmenu':\n      this.evtContextMenu(event as MouseEvent);\n      break;\n    }\n  }\n\n  /**\n   * Attach the application shell to the DOM.\n   *\n   * @param id - The id of the host node for the shell, or `''`.\n   *\n   * #### Notes\n   * If the id is not provided, the document body will be the host.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected attachShell(id: string): void {\n    Widget.attach(this.shell, (id && document.getElementById(id)) || document.body);\n  }\n\n  /**\n   * Add the application event listeners.\n   *\n   * #### Notes\n   * The default implementation of this method adds listeners for\n   * `'keydown'` and `'resize'` events.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected addEventListeners(): void {\n    document.addEventListener('contextmenu', this);\n    document.addEventListener('keydown', this, true);\n    window.addEventListener('resize', this);\n  }\n\n  /**\n   * A method invoked on a document `'keydown'` event.\n   *\n   * #### Notes\n   * The default implementation of this method invokes the key down\n   * processing method of the application command registry.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtKeydown(event: KeyboardEvent): void {\n    this.commands.processKeydownEvent(event);\n  }\n\n  /**\n   * A method invoked on a document `'contextmenu'` event.\n   *\n   * #### Notes\n   * The default implementation of this method opens the application\n   * `contextMenu` at the current mouse position.\n   *\n   * If the application context menu has no matching content *or* if\n   * the shift key is pressed, the default browser context menu will\n   * be opened instead.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtContextMenu(event: MouseEvent): void {\n    if (event.shiftKey) {\n      return;\n    }\n    if (this.contextMenu.open(event)) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * A method invoked on a window `'resize'` event.\n   *\n   * #### Notes\n   * The default implementation of this method updates the shell.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtResize(event: Event): void {\n    this.shell.update();\n  }\n\n  private _started = false;\n  private _pluginMap = Private.createPluginMap();\n  private _serviceMap = Private.createServiceMap();\n  private _delegate = new PromiseDelegate<void>();\n}\n\n\n/**\n * The namespace for the `Application` class statics.\n */\nexport\nnamespace Application {\n  /**\n   * An options object for creating an application.\n   */\n  export\n  interface IOptions<T extends Widget> {\n    /**\n     * The shell widget to use for the application.\n     *\n     * This should be a newly created and initialized widget.\n     *\n     * The application will attach the widget to the DOM.\n     */\n    shell: T;\n\n    /**\n     * A custom renderer for the context menu.\n     */\n    contextMenuRenderer?: Menu.IRenderer;\n  }\n\n  /**\n   * An options object for application startup.\n   */\n  export\n  interface IStartOptions {\n    /**\n     * The ID of the DOM node to host the application shell.\n     *\n     * #### Notes\n     * If this is not provided, the document body will be the host.\n     */\n    hostID?: string;\n\n    /**\n     * The plugins to activate on startup.\n     *\n     * #### Notes\n     * These will be *in addition* to any `autoStart` plugins.\n     */\n    startPlugins?: string[];\n\n    /**\n     * The plugins to **not** activate on startup.\n     *\n     * #### Notes\n     * This will override `startPlugins` and any `autoStart` plugins.\n     */\n    ignorePlugins?: string[];\n  }\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which holds the full application state for a plugin.\n   */\n  export\n  interface IPluginData {\n    /**\n     * The human readable id of the plugin.\n     */\n    readonly id: string;\n\n    /**\n     * Whether the plugin should be activated on application start.\n     */\n    readonly autoStart: boolean;\n\n    /**\n     * The types of required services for the plugin, or `[]`.\n     */\n    readonly requires: Token<any>[];\n\n    /**\n     * The types of optional services for the the plugin, or `[]`.\n     */\n    readonly optional: Token<any>[];\n\n    /**\n     * The type of service provided by the plugin, or `null`.\n     */\n    readonly provides: Token<any> | null;\n\n    /**\n     * The function which activates the plugin.\n     */\n    readonly activate: (app: any, ...args: any[]) => any;\n\n    /**\n     * Whether the plugin has been activated.\n     */\n    activated: boolean;\n\n    /**\n     * The resolved service for the plugin, or `null`.\n     */\n    service: any | null;\n\n    /**\n     * The pending resolver promise, or `null`.\n     */\n    promise: Promise<void> | null;\n  }\n\n  /**\n   * A type alias for a mapping of plugin id to plugin data.\n   */\n  export\n  type PluginMap = { [id: string]: IPluginData };\n\n  /**\n   * A type alias for a mapping of service token to plugin id.\n   */\n  export\n  type ServiceMap = Map<Token<any>, string>;\n\n  /**\n   * Create a new plugin map.\n   */\n  export\n  function createPluginMap(): PluginMap {\n    return Object.create(null);\n  }\n\n  /**\n   * Create a new service map.\n   */\n  export\n  function createServiceMap(): ServiceMap {\n    return new Map<Token<any>, string>();\n  }\n\n  /**\n   * Create a normalized plugin data object for the given plugin.\n   */\n  export\n  function createPluginData(plugin: IPlugin<any, any>): IPluginData {\n    return {\n      id: plugin.id,\n      service: null,\n      promise: null,\n      activated: false,\n      activate: plugin.activate,\n      provides: plugin.provides || null,\n      autoStart: plugin.autoStart || false,\n      requires: plugin.requires ? plugin.requires.slice() : [],\n      optional: plugin.optional ? plugin.optional.slice() : []\n    };\n  }\n\n  /**\n   * Ensure no cycle is present in the plugin resolution graph.\n   *\n   * If a cycle is detected, an error will be thrown.\n   */\n  export\n  function ensureNoCycle(data: IPluginData, pluginMap: PluginMap, serviceMap: ServiceMap): void {\n    let dependencies = data.requires.concat(data.optional);\n    // Bail early if there cannot be a cycle.\n    if (!data.provides || dependencies.length === 0) {\n      return;\n    }\n\n    // Setup a stack to trace service resolution.\n    let trace = [data.id];\n\n    // Throw an exception if a cycle is present.\n    if (dependencies.some(visit)) {\n      throw new Error(`Cycle detected: ${trace.join(' -> ')}.`);\n    }\n\n    function visit(token: Token<any>): boolean {\n      if (token === data.provides) {\n        return true;\n      }\n      let id = serviceMap.get(token);\n      if (!id) {\n        return false;\n      }\n      let other = pluginMap[id];\n      let otherDependencies = other.requires.concat(other.optional);\n      if (otherDependencies.length === 0) {\n        return false;\n      }\n      trace.push(id);\n      if (otherDependencies.some(visit)) {\n        return true;\n      }\n      trace.pop();\n      return false;\n    }\n  }\n\n  /**\n   * Collect the IDs of the plugins to activate on startup.\n   */\n  export\n  function collectStartupPlugins(pluginMap: PluginMap, options: Application.IStartOptions): string[] {\n    // Create a map to hold the plugin IDs.\n    let resultMap: { [id: string]: boolean } = Object.create(null);\n\n    // Collect the auto-start plugins.\n    for (let id in pluginMap) {\n      if (pluginMap[id].autoStart) {\n        resultMap[id] = true;\n      }\n    }\n\n    // Add the startup plugins.\n    if (options.startPlugins) {\n      for (let id of options.startPlugins) {\n        resultMap[id] = true;\n      }\n    }\n\n    // Remove the ignored plugins.\n    if (options.ignorePlugins) {\n      for (let id of options.ignorePlugins) {\n        delete resultMap[id];\n      }\n    }\n\n    // Return the final startup plugins.\n    return Object.keys(resultMap);\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n"]}