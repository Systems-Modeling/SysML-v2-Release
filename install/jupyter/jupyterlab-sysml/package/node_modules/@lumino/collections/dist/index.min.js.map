{"version":3,"sources":["../src/bplustree.ts","../src/linkedlist.ts"],"names":["BPlusTree","Private","cmp","this","_root","LeafNode","Object","defineProperty","prototype","size","node","firstLeaf","items","undefined","lastLeaf","iter","iterItems","retro","retroItems","slice","start","stop","sliceItems","retroSlice","retroSliceItems","at","index","itemAt","has","key","hasItem","indexOf","get","getItem","assign","clear","update","insert","item","existing","insertItem","maybeSplitRoot","_this","each","delete","deleteItem","maybeExtractRoot","remove","removeItem","from","tree","BranchNode","sizes","children","length","next","prev","type","leaf","ForwardIterator","RetroIterator","Math","max","min","count","empty","i","findPivotIndexByIndex","i_1","findPivotIndexByKey","findKeyIndex","i_2","i_3","existing_1","i_4","ArrayExt","child","prevSize","currSize","width","MAX_NODE_WIDTH","splitNode","updateSizes","i_5","removeAt","MIN_NODE_WIDTH","joinChild","root","pop","_node","_index","_count","clone","n","c","last","next_1","v1_1","v2_1","push","c1","c2","v1","v2","sibling","hasNext","isLeaf","hasExtra","s","shift","unshift","_a","apply","_b","_c","_d","_e","_f","exports","LinkedList","_first","_last","_size","value","ForwardValueIterator","RetroValueIterator","nodes","ForwardNodeIterator","retroNodes","RetroNodeIterator","values","addLast","removeLast","addFirst","removeFirst","LinkedListNode","insertBefore","ref","list","Error","_ref","insertAfter","removeNode"],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2018, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  ArrayExt, IIterable, IIterator, IRetroable, IterableOrArrayLike, each, empty\n} from \"@lumino/algorithm\";\n\n\n/**\n * A generic B+ tree.\n *\n * #### Notes\n * Most operations have `O(log32 n)` or better complexity.\n */\nexport\nclass BPlusTree<T> implements IIterable<T>, IRetroable<T> {\n  /**\n   * Construct a new B+ tree.\n   *\n   * @param cmp - The item comparison function for the tree.\n   */\n  constructor(cmp: (a: T, b: T) => number) {\n    this.cmp = cmp;\n  }\n\n  /**\n   * The item comparison function for the tree.\n   *\n   * #### Complexity\n   * `O(1)`\n   */\n  readonly cmp: (a: T, b: T) => number;\n\n  /**\n   * Whether the tree is empty.\n   *\n   * #### Complexity\n   * `O(1)`\n   */\n  get isEmpty(): boolean {\n    return this._root.size === 0;\n  }\n\n  /**\n   * The size of the tree.\n   *\n   * #### Complexity\n   * `O(1)`\n   */\n  get size(): number {\n    return this._root.size;\n  }\n\n  /**\n   * The first item in the tree.\n   *\n   * This is `undefined` if the tree is empty.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  get first(): T | undefined {\n    let node = Private.firstLeaf(this._root);\n    return node.size > 0 ? node.items[0] : undefined;\n  }\n\n  /**\n   * The last item in the tree.\n   *\n   * This is `undefined` if the tree is empty.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  get last(): T | undefined {\n    let node = Private.lastLeaf(this._root);\n    return node.size > 0 ? node.items[node.size - 1] : undefined;\n  }\n\n  /**\n   * Create an iterator over the items in the tree.\n   *\n   * @returns A new iterator starting with the first item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  iter(): IIterator<T> {\n    return Private.iterItems(this._root);\n  }\n\n  /**\n   * Create a reverse iterator over the items in the tree.\n   *\n   * @returns A new iterator starting with the last item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  retro(): IIterator<T> {\n    return Private.retroItems(this._root);\n  }\n\n  /**\n   * Create an iterator for a slice of items in the tree.\n   *\n   * @param start - The index of the first item, inclusive. This\n   *   should be `< stop`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `0`.\n   *\n   * @param stop - The index of the last item, exclusive. This\n   *   should be `> start`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `size`.\n   *\n   * @returns A new iterator starting with the specified item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  slice(start?: number, stop?: number): IIterator<T> {\n    return Private.sliceItems(this._root, start, stop);\n  }\n\n  /**\n   * Create a reverse iterator for a slice of items in the tree.\n   *\n   * @param start - The index of the first item, inclusive. This\n   *   should be `> stop`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `size - 1`.\n   *\n   * @param stop - The index of the last item, exclusive. This\n   *   should be `< start`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `-size - 1`.\n   *\n   * @returns A new reverse iterator starting with the specified item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  retroSlice(start?: number, stop?: number): IIterator<T> {\n    return Private.retroSliceItems(this._root, start, stop);\n  }\n\n  /**\n   * Get the item at a particular index.\n   *\n   * @param index - The index of the item of interest. Negative\n   *   values are taken as an offset from the end of the tree.\n   *\n   * @returns The item at the specified index, or `undefined` if\n   *   the index is out of range.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  at(index: number): T | undefined {\n    return Private.itemAt(this._root, index);\n  }\n\n  /**\n   * Test whether the tree has an item which matches a key.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - A function which compares an item against the key.\n   *\n   * @returns `true` if the tree has an item which matches the given\n   *   key, `false` otherwise.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  has<U>(key: U, cmp: (item: T, key: U) => number): boolean {\n    return Private.hasItem(this._root, key, cmp);\n  }\n\n  /**\n   * Get the index of an item which matches a key.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - A function which compares an item against the key.\n   *\n   * @returns The index of the item which matches the given key. A\n   *   negative value means that a matching item does not exist in\n   *   the tree, but if one did it would reside at `-index - 1`.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  indexOf<U>(key: U, cmp: (item: T, key: U) => number): number {\n    return Private.indexOf(this._root, key, cmp);\n  }\n\n  /**\n   * Get the item which matches a key.\n   *\n   * @param item - The key of interest.\n   *\n   * @param cmp - A function which compares an item against the key.\n   *\n   * @returns The item which matches the given key, or `undefined` if\n   *   the tree does not have a matching item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  get<U>(key: U, cmp: (item: T, key: U) => number): T | undefined {\n    return Private.getItem(this._root, key, cmp);\n  }\n\n  /**\n   * Assign new items to the tree, replacing all current items.\n   *\n   * @param items - The items to assign to the tree.\n   *\n   * #### Complexity\n   * `O(n log32 n)`\n   */\n  assign(items: IterableOrArrayLike<T>): void {\n    this.clear();\n    this.update(items);\n  }\n\n  /**\n   * Insert an item into the tree.\n   *\n   * @param item - The item of interest.\n   *\n   * @returns If the given item matches an existing item in the tree,\n   *   the given item will replace it, and the existing item will be\n   *   returned. Otherwise, this method returns `undefined`.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  insert(item: T): T | undefined {\n    let existing = Private.insertItem(this._root, item, this.cmp);\n    this._root = Private.maybeSplitRoot(this._root);\n    return existing;\n  }\n\n  /**\n   * Update the tree with multiple items.\n   *\n   * @param items - The items to insert into the tree.\n   *\n   * #### Complexity\n   * `O(k log32 n)`\n   */\n  update(items: IterableOrArrayLike<T>): void {\n    each(items, item => { this.insert(item); });\n  }\n\n  /**\n   * Delete an item which matches a particular key.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - A function which compares an item against the key.\n   *\n   * @returns The item removed from the tree, or `undefined` if no\n   *   item matched the given key.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  delete<U>(key: U, cmp: (item: T, key: U) => number): T | undefined {\n    let item = Private.deleteItem(this._root, key, cmp);\n    this._root = Private.maybeExtractRoot(this._root);\n    return item;\n  }\n\n  /**\n   * Remove an item at a particular index.\n   *\n   * @param index - The index of the item to remove. Negative\n   *   values are taken as an offset from the end of the tree.\n   *\n   * @returns The item removed from the tree, or `undefined` if\n   *   the given index is out of range.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  remove(index: number): T | undefined {\n    let item = Private.removeItem(this._root, index);\n    this._root = Private.maybeExtractRoot(this._root);\n    return item;\n  }\n\n  /**\n   * Clear the contents of the tree.\n   *\n   * #### Complexity\n   * `O(n)`\n   */\n  clear(): void {\n    Private.clear(this._root);\n    this._root = new Private.LeafNode<T>();\n  }\n\n  private _root: Private.Node<T> = new Private.LeafNode<T>();\n}\n\n\n/**\n * The namespace for the `BPlusTree` class statics.\n */\nexport\nnamespace BPlusTree {\n  /**\n   * Create a new B+ tree populated with the given items.\n   *\n   * @param items - The items to add to the tree.\n   *\n   * @param cmp - The item comparison function for the tree.\n   *\n   * @returns A new B+ tree populated with the given items.\n   *\n   * #### Complexity\n   * `O(n log32 n)`\n   */\n  export\n  function from<T>(items: IterableOrArrayLike<T>, cmp: (a: T, b: T) => number): BPlusTree<T> {\n    let tree = new BPlusTree<T>(cmp);\n    tree.assign(items);\n    return tree;\n  }\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A const enum of the B+ tree node types.\n   */\n  export\n  const enum NodeType { Branch, Leaf }\n\n  /**\n   * A branch node in a B+ tree.\n   */\n  export\n  class BranchNode<T> {\n    /**\n     * The left-most item of each child subtree.\n     */\n    readonly items: T[] = [];\n\n    /**\n     * The cumulative sizes of each child subtree.\n     */\n    readonly sizes: number[] = [];\n\n    /**\n     * The child nodes of this branch node.\n     */\n    readonly children: Node<T>[] = [];\n\n    /**\n     * The discriminated type of the node.\n     */\n    get type(): NodeType.Branch {\n      return NodeType.Branch;\n    }\n\n    /**\n     * The total number of items in the subtree.\n     */\n    get size(): number {\n      return this.sizes[this.sizes.length - 1];\n    }\n\n    /**\n     * The tree width of the node.\n     */\n    get width(): number {\n      return this.children.length;\n    }\n  }\n\n  /**\n   * A leaf node in a B+ tree.\n   */\n  export\n  class LeafNode<T> {\n    /**\n     * The next sibling leaf node of this leaf node.\n     */\n    next: LeafNode<T> | null = null;\n\n    /**\n     * The previous sibling leaf node of this leaf node.\n     */\n    prev: LeafNode<T> | null = null;\n\n    /**\n     * The items of the leaf.\n     */\n    readonly items: T[] = [];\n\n    /**\n     * The discriminated type of the node.\n     */\n    get type(): NodeType.Leaf {\n      return NodeType.Leaf;\n    }\n\n    /**\n     * The total number of items in the leaf.\n     */\n    get size(): number {\n      return this.items.length;\n    }\n\n    /**\n     * The tree width of the node.\n     */\n    get width(): number {\n      return this.items.length;\n    }\n  }\n\n  /**\n   * A type alias for the B+ tree nodes.\n   */\n  export\n  type Node<T> = BranchNode<T> | LeafNode<T>;\n\n  /**\n   * Get the first leaf node in the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @returns The first leaf node in the tree.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export\n  function firstLeaf<T>(node: Node<T>): LeafNode<T> {\n    while (node.type === NodeType.Branch) {\n      node = node.children[0];\n    }\n    return node;\n  }\n\n  /**\n   * Get the last leaf node in the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @returns The last leaf node in the tree.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export\n  function lastLeaf<T>(node: Node<T>): LeafNode<T> {\n    while (node.type === NodeType.Branch) {\n      node = node.children[node.children.length - 1];\n    }\n    return node;\n  }\n\n  /**\n   * Create a forward iterator for the items in the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @returns A new forward iterator starting with the first item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export\n  function iterItems<T>(node: Node<T>): IIterator<T> {\n    let leaf = firstLeaf(node);\n    return new ForwardIterator<T>(leaf, 0, -1);\n  }\n\n  /**\n   * Create a reverse iterator for the items in the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @returns A new reverse iterator starting with the last item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export\n  function retroItems<T>(node: Node<T>): IIterator<T> {\n    let leaf = lastLeaf(node);\n    return new RetroIterator<T>(leaf, leaf.size - 1, -1);\n  }\n\n  /**\n   * Create an iterator for a slice of items in the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @param start - The index of the first item, inclusive. This\n   *   should be `< stop`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `0`.\n   *\n   * @param stop - The index of the last item, exclusive. This\n   *   should be `> start`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `size`.\n   *\n   * @returns A new iterator starting with the specified item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export\n  function sliceItems<T>(node: Node<T>, start?: number, stop?: number): IIterator<T> {\n    // Normalize the start index.\n    if (start === undefined) {\n      start = 0;\n    } else if (start < 0) {\n      start = Math.max(0, start + node.size);\n    } else {\n      start = Math.min(start, node.size);\n    }\n\n    // Normalize the stop index.\n    if (stop === undefined) {\n      stop = node.size;\n    } else if (stop < 0) {\n      stop = Math.max(0, stop + node.size);\n    } else {\n      stop = Math.min(stop, node.size);\n    }\n\n    // Compute effective count.\n    let count = Math.max(0, stop - start);\n\n    // Bail early if there is nothing to iterate.\n    if (count === 0) {\n      return empty<T>();\n    }\n\n    // Find the starting leaf node and local index.\n    while (node.type === NodeType.Branch) {\n      let i = findPivotIndexByIndex(node.sizes, start);\n      if (i > 0) start -= node.sizes[i - 1];\n      node = node.children[i];\n    }\n\n    // Return the forward iterator for the range.\n    return new ForwardIterator<T>(node, start, count);\n  }\n\n  /**\n   * Create a reverse iterator for a slice of items in the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @param start - The index of the first item, inclusive. This\n   *   should be `> stop`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `size - 1`.\n   *\n   * @param stop - The index of the last item, exclusive. This\n   *   should be `< start`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `-size - 1`.\n   *\n   * @returns A new reverse iterator starting with the specified item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export\n  function retroSliceItems<T>(node: Node<T>, start?: number, stop?: number): IIterator<T> {\n    // Normalize the start index.\n    if (start === undefined) {\n      start = node.size - 1;\n    } else if (start < 0) {\n      start = Math.max(-1, start + node.size);\n    } else {\n      start = Math.min(start, node.size - 1);\n    }\n\n    // Normalize the stop index.\n    if (stop === undefined) {\n      stop = -1;\n    } else if (stop < 0) {\n      stop = Math.max(-1, stop + node.size);\n    } else {\n      stop = Math.min(stop, node.size - 1);\n    }\n\n    // Compute the effective count.\n    let count = Math.max(0, start - stop);\n\n    // Bail early if there is nothing to iterate.\n    if (count === 0) {\n      return empty<T>();\n    }\n\n    // Find the starting leaf node and local index.\n    while (node.type === NodeType.Branch) {\n      let i = findPivotIndexByIndex(node.sizes, start);\n      if (i > 0) start -= node.sizes[i - 1];\n      node = node.children[i];\n    }\n\n    // Return the retro iterator for the range.\n    return new RetroIterator<T>(node, start, count);\n  }\n\n  /**\n   * Get the item at the specified index.\n   *\n   * @param node - The root node of interest.\n   *\n   * @param index - The index of the item of interest. Negative\n   *   values are taken as an offset from the end of the tree.\n   *\n   * @returns The item at the specified index, or `undefined` if\n   *   the index is out of range.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export\n  function itemAt<T>(node: Node<T>, index: number): T | undefined {\n    // Wrap negative indices.\n    if (index < 0) {\n      index += node.size;\n    }\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= node.size) {\n      return undefined;\n    }\n\n    // Find the containing leaf node and local index.\n    while (node.type === NodeType.Branch) {\n      let i = findPivotIndexByIndex(node.sizes, index);\n      if (i > 0) index -= node.sizes[i - 1];\n      node = node.children[i];\n    }\n\n    // Return the item at the specified index.\n    return node.items[index];\n  }\n\n  /**\n   * Test whether the tree contains an item which matches a key.\n   *\n   * @param node - The root node of interest.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - The key comparison function.\n   *\n   * @returns Whether the tree contains a matching item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export\n  function hasItem<T, U>(node: Node<T>, key: U, cmp: (item: T, key: U) => number): boolean {\n    // Find the containing leaf node.\n    while (node.type === NodeType.Branch) {\n      let i = findPivotIndexByKey(node.items, key, cmp);\n      node = node.children[i];\n    }\n\n    // Find the key index.\n    let i = findKeyIndex(node.items, key, cmp);\n\n    // Return whether or not the node contains a matching item.\n    return i >= 0;\n  }\n\n  /**\n   * Get the index of the item which matches a key.\n   *\n   * @param node - The node of interest.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - The key comparison function.\n   *\n   * @returns The index of the item which matches the given key. A\n   *   negative value means that a matching item does not exist in\n   *   the tree, but if one did it would reside at `-index - 1`.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export\n  function indexOf<T, U>(node: Node<T>, key: U, cmp: (item: T, key: U) => number): number {\n    // Set up the global index.\n    let index = 0;\n\n    // Find the containing leaf node and global index.\n    while (node.type === NodeType.Branch) {\n      let i = findPivotIndexByKey(node.items, key, cmp);\n      if (i > 0) index += node.sizes[i - 1];\n      node = node.children[i];\n    }\n\n    // Find the key index.\n    let i = findKeyIndex(node.items, key, cmp);\n\n    // Return the final computed index.\n    return i >= 0 ? index + i : -index + i;\n  }\n\n  /**\n   * Get the item for a particular key.\n   *\n   * @param node - The node of interest.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - The key comparison function.\n   *\n   * @returns The item for the specified key, or `undefined` if\n   *   the tree does not have a matching item for the key.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export\n  function getItem<T, U>(node: Node<T>, key: U, cmp: (item: T, key: U) => number): T | undefined {\n    // Find the containing leaf node.\n    while (node.type === NodeType.Branch) {\n      let i = findPivotIndexByKey(node.items, key, cmp);\n      node = node.children[i];\n    }\n\n    // Find the key index.\n    let i = findKeyIndex(node.items, key, cmp);\n\n    // Return the item for the given key.\n    return i >= 0 ? node.items[i] : undefined;\n  }\n\n  /**\n   * Insert an item into the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @param item - The item of interest.\n   *\n   * @param cmp - The item comparison function.\n   *\n   * @returns If the given item matches an existing item in the tree,\n   *   the given item will replace it, and the existing item will be\n   *   returned. Otherwise, this function returns `undefined`.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   *\n   * #### Notes\n   * The root may be overfull after calling this function.\n   */\n  export\n  function insertItem<T>(node: Node<T>, item: T, cmp: (a: T, b: T) => number): T | undefined {\n    // Handle leaf nodes first.\n    if (node.type === NodeType.Leaf) {\n      // Find the index for the given item.\n      let i = findKeyIndex(node.items, item, cmp);\n\n      // Fetch the existing item and insert the new item.\n      let existing: T | undefined;\n      if (i >= 0) {\n        existing = node.items[i];\n        node.items[i] = item;\n      } else {\n        existing = undefined;\n        ArrayExt.insert(node.items, -i - 1, item);\n      }\n\n      // Return the existing item.\n      return existing;\n    }\n\n    // Find the pivot index for the insert.\n    let i = findPivotIndexByKey(node.items, item, cmp);\n\n    // Fetch the pivot child.\n    let child = node.children[i];\n\n    // Fetch the current size of the child.\n    let prevSize = child.size;\n\n    // Recursively insert the item into the child.\n    let existing = insertItem(child, item, cmp);\n\n    // Fetch the updated size of the child.\n    let currSize = child.size;\n\n    // Update the item state of the branch.\n    node.items[i] = child.items[0];\n\n    // Bail early if the child size did not change.\n    if (prevSize === currSize) {\n      return existing;\n    }\n\n    // Split the child if it's overfull.\n    if (child.width > MAX_NODE_WIDTH) {\n      let next = splitNode(child);\n      ArrayExt.insert(node.children, i + 1, next);\n      ArrayExt.insert(node.items, i + 1, next.items[0]);\n    }\n\n    // Update the dirty sizes of the branch.\n    updateSizes(node, i);\n\n    // Return the existing item.\n    return existing;\n  }\n\n  /**\n   * Delete an item in the tree.\n   *\n   * @param node - The node of interest.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - The key comparison function.\n   *\n   * @returns The deleted item or `undefined`.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   *\n   * #### Notes\n   * The root may be underfull after calling this function.\n   */\n  export\n  function deleteItem<T, U>(node: Node<T>, key: U, cmp: (item: T, key: U) => number): T | undefined {\n    // Handle leaf nodes first.\n    if (node.type === NodeType.Leaf) {\n      // Find the index for the given key.\n      let i = findKeyIndex(node.items, key, cmp);\n\n      // Bail early if the item does not exist.\n      if (i < 0) {\n        return undefined;\n      }\n\n      // Remove the item at the computed index.\n      return ArrayExt.removeAt(node.items, i);\n    }\n\n    // Find the pivot index for the delete.\n    let i = findPivotIndexByKey(node.items, key, cmp);\n\n    // Fetch the pivot child.\n    let child = node.children[i];\n\n    // Fetch the current size of the child.\n    let prevSize = child.size;\n\n    // Recursively remove the item from the child.\n    let item = deleteItem(child, key, cmp);\n\n    // Fetch the updated size of the child.\n    let currSize = child.size;\n\n    // Bail early if the child size did not change.\n    if (prevSize === currSize) {\n      return item;\n    }\n\n    // Update the item state of the branch.\n    node.items[i] = child.items[0];\n\n    // Join the child if it's underfull.\n    if (child.width < MIN_NODE_WIDTH) {\n      i = joinChild(node, i);\n    }\n\n    // Update the dirty sizes of the branch.\n    updateSizes(node, i);\n\n    // Return the deleted item.\n    return item;\n  }\n\n  /**\n   * Remove an item from the tree.\n   *\n   * @param node - The node of interest.\n   *\n   * @param index - The index of interest.\n   *\n   * @returns The removed item or `undefined`.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   *\n   * #### Notes\n   * The root may be underfull after calling this function.\n   */\n  export\n  function removeItem<T>(node: Node<T>, index: number): T | undefined {\n    // Wrap negative indices.\n    if (index < 0) {\n      index += node.size;\n    }\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= node.size) {\n      return undefined;\n    }\n\n    // Handle leaf nodes first.\n    if (node.type === NodeType.Leaf) {\n      return ArrayExt.removeAt(node.items, index);\n    }\n\n    // Find the pivot index for the remove.\n    let i = findPivotIndexByIndex(node.sizes, index);\n    if (i > 0) index -= node.sizes[i];\n\n    // Fetch the pivot child.\n    let child = node.children[i];\n\n    // Recursively remove the item from the child.\n    let item = removeItem(child, index);\n\n    // Update the item state of the branch.\n    node.items[i] = child.items[0];\n\n    // Join the child if it's underfull.\n    if (child.width < MIN_NODE_WIDTH) {\n      i = joinChild(node, i);\n    }\n\n    // Update the dirty sizes of the branch.\n    updateSizes(node, i);\n\n    // Return the removed item.\n    return item;\n  }\n\n  /**\n   * Recursively clear the contents of a node.\n   *\n   * @param node - The node of interest.\n   *\n   * #### Complexity\n   * `O(n)`\n   */\n  export\n  function clear<T>(node: Node<T>): void {\n    if (node.type === NodeType.Branch) {\n      each(node.children, clear);\n      node.children.length = 0;\n      node.sizes.length = 0;\n      node.items.length = 0;\n    } else {\n      node.items.length = 0;\n      node.next = null;\n      node.prev = null;\n    }\n  }\n\n  /**\n   * Split a root node and create a new root, if needed.\n   *\n   * @param node - The root node of interest.\n   *\n   * @returns The new root node.\n   */\n  export\n  function maybeSplitRoot<T>(node: Node<T>): Node<T> {\n    // Bail early if the current root is not overfull.\n    if (node.width <= MAX_NODE_WIDTH) {\n      return node;\n    }\n\n    // Create a new root branch node.\n    let root = new BranchNode<T>();\n\n    // Split the node to the right and create a new sibling.\n    let next = splitNode(node);\n\n    // Add the sizes to the root.\n    root.sizes[0] = node.size;\n    root.sizes[1] = node.size + next.size;\n\n    // Add the children to the root.\n    root.children[0] = node;\n    root.children[1] = next;\n\n    // Add the items to the root.\n    root.items[0] = node.items[0];\n    root.items[1] = next.items[0];\n\n    // Return the new root node.\n    return root;\n  }\n\n  /**\n   * Extract a single node child as a new root, if needed.\n   *\n   * @param node - The root node of interest.\n   *\n   * @returns The new root node.\n   */\n  export\n  function maybeExtractRoot<T>(node: Node<T>): Node<T> {\n    // Bail early if the node it already a leaf.\n    if (node.type === NodeType.Leaf) {\n      return node;\n    }\n\n    // Bail early if the branch has more than one child.\n    if (node.children.length > 1) {\n      return node;\n    }\n\n    // Extract the sole remaining child as the new root.\n    let root = node.children.pop()!;\n\n    // Clear the rest of the node state.\n    clear(node);\n\n    // Return the new root.\n    return root;\n  }\n\n  /**\n   * The maximum width for a node in the tree.\n   */\n  const MAX_NODE_WIDTH = 32;\n\n  /**\n   * The minimum width for a node in the tree.\n   */\n  const MIN_NODE_WIDTH = MAX_NODE_WIDTH >> 1;\n\n  /**\n   * A forward iterator for a B+ tree.\n   */\n  class ForwardIterator<T> implements IIterator<T> {\n    /**\n     * Construct a new forward iterator.\n     *\n     * @param node - The first leaf node in the chain.\n     *\n     * @param index - The local index of the first item.\n     *\n     * @param count - The number of items to iterate. A value `< 0`\n     *   will iterate all available items.\n     */\n    constructor(node: LeafNode<T> | null, index: number, count: number) {\n      this._node = node;\n      this._index = index;\n      this._count = count;\n    }\n\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    iter(): IIterator<T> {\n      return this;\n    }\n\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    clone(): IIterator<T> {\n      return new ForwardIterator<T>(this._node, this._index, this._count);\n    }\n\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    next(): T | undefined {\n      if (this._node === null || this._count === 0) {\n        return undefined;\n      }\n      if (this._index >= this._node.size) {\n        this._node = this._node.next;\n        this._index = 0;\n        return this.next();\n      }\n      if (this._count > 0) {\n        this._count--;\n      }\n      return this._node.items[this._index++];\n    }\n\n    private _index: number;\n    private _count: number;\n    private _node: LeafNode<T> | null;\n  }\n\n  /**\n   * A reverse iterator for a B+ tree.\n   */\n  class RetroIterator<T> implements IIterator<T> {\n    /**\n     * Construct a new retro iterator.\n     *\n     * @param node - The last leaf node in the chain.\n     *\n     * @param index - The local index of the last item.\n     *\n     * @param count - The number of items to iterate. A value `< 0`\n     *   will iterate all available items.\n     */\n    constructor(node: LeafNode<T> | null, index: number, count: number) {\n      this._node = node;\n      this._index = index;\n      this._count = count;\n    }\n\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    iter(): IIterator<T> {\n      return this;\n    }\n\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    clone(): IIterator<T> {\n      return new RetroIterator<T>(this._node, this._index, this._count);\n    }\n\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    next(): T | undefined {\n      if (this._node === null || this._count === 0) {\n        return undefined;\n      }\n      if (this._index >= this._node.size) {\n        this._index = this._node.size - 1;\n      }\n      if (this._index < 0) {\n        this._node = this._node.prev;\n        this._index = this._node ? this._node.size - 1 : -1;\n        return this.next();\n      }\n      if (this._count > 0) {\n        this._count--;\n      }\n      return this._node.items[this._index--];\n    }\n\n    private _index: number;\n    private _count: number;\n    private _node: LeafNode<T> | null;\n  }\n\n  /**\n   * Find the pivot index for a particular local index.\n   */\n  function findPivotIndexByIndex(sizes: number[], index: number): number {\n    let n = sizes.length;\n    for (let i = 0; i < n; ++i) {\n      if (sizes[i] > index) {\n        return i;\n      }\n    }\n    return n - 1;\n  }\n\n  /**\n   * Find the pivot index for a particular key.\n   */\n  function findPivotIndexByKey<T, U>(items: T[], key: U, cmp: (item: T, key: U) => number): number {\n    let n = items.length;\n    for (let i = 1; i < n; ++i) {\n      if (cmp(items[i], key) > 0) {\n        return i - 1;\n      }\n    }\n    return n - 1;\n  }\n\n  /**\n   * Find the key index for a particular key.\n   */\n  function findKeyIndex<T, U>(items: T[], key: U, cmp: (item: T, key: U) => number): number {\n    let n = items.length;\n    for (let i = 0; i < n; ++i) {\n      let c = cmp(items[i], key);\n      if (c === 0) {\n        return i;\n      }\n      if (c > 0) {\n        return -i - 1;\n      }\n    }\n    return -n - 1;\n  }\n\n  /**\n   * Update the sizes of a branch node starting at the given index.\n   */\n  function updateSizes<T>(node: BranchNode<T>, i: number): void {\n    let { sizes, children } = node;\n    let last = i > 0 ? sizes[i - 1] : 0;\n    for (let n = children.length; i < n; ++i) {\n      last = sizes[i] = last + children[i].size;\n    }\n    sizes.length = children.length;\n  }\n\n  /**\n   * Split a node and return its new next sibling.\n   *\n   * @param node - The node of interest.\n   *\n   * @returns The new next sibling node.\n   */\n  function splitNode<T>(node: Node<T>): Node<T> {\n    // Handle leaf nodes first.\n    if (node.type === NodeType.Leaf) {\n      // Create the new sibling leaf node.\n      let next = new LeafNode<T>();\n\n      // Move the items to the new sibling.\n      let v1 = node.items;\n      let v2 = next.items;\n      for (let i = MIN_NODE_WIDTH, n = v1.length; i < n; ++i) {\n        v2.push(v1[i]);\n      }\n      v1.length = MIN_NODE_WIDTH;\n\n      // Patch up the sibling links.\n      if (node.next) node.next.prev = next;\n      next.next = node.next;\n      next.prev = node;\n      node.next = next;\n\n      // Return the new next sibling.\n      return next;\n    }\n\n    // Create the new sibling branch node.\n    let next = new BranchNode<T>();\n\n    // Move the children to the new sibling.\n    let c1 = node.children;\n    let c2 = next.children;\n    for (let i = MIN_NODE_WIDTH, n = c1.length; i < n; ++i) {\n      c2.push(c1[i]);\n    }\n    c1.length = MIN_NODE_WIDTH;\n\n    // Move the items to the new sibling.\n    let v1 = node.items;\n    let v2 = next.items;\n    for (let i = MIN_NODE_WIDTH, n = v1.length; i < n; ++i) {\n      v2.push(v1[i]);\n    }\n    v1.length = MIN_NODE_WIDTH;\n\n    // Update the dirty sizes of the nodes.\n    updateSizes(node, MIN_NODE_WIDTH);\n    updateSizes(next, 0);\n\n    // Return the new next sibling.\n    return next;\n  }\n\n  /**\n   * Join a child node of a branch with one of its siblings.\n   *\n   * @param node - The branch node of interest.\n   *\n   * @param i - The index of the child node of interest.\n   *\n   * @returns The first modified index.\n   *\n   * #### Notes\n   * This may cause the branch to become underfull.\n   */\n  function joinChild<T>(node: BranchNode<T>, i: number): number {\n    // Fetch the child to be joined.\n    let child = node.children[i];\n\n    // Fetch the relevant sibling.\n    let sibling = i === 0 ? node.children[i + 1] : node.children[i - 1];\n\n    // Compute the flags which control the join behavior.\n    let hasNext = i === 0;\n    let isLeaf = child.type === NodeType.Leaf;\n    let hasExtra = sibling.width > MIN_NODE_WIDTH;\n\n    // Join case #1: steal from next sibling leaf\n    if (isLeaf && hasExtra && hasNext) {\n      // Cast the children as leaves.\n      let c = child as LeafNode<T>;\n      let s = sibling as LeafNode<T>;\n\n      // Steal an item.\n      c.items.push(s.items.shift()!);\n\n      // Update the branch items.\n      node.items[i + 1] = s.items[0];\n\n      // Return the first modified index.\n      return i;\n    }\n\n    // Join case #2: steal from previous sibling leaf\n    if (isLeaf && hasExtra && !hasNext) {\n      // Cast the children as leaves.\n      let c = child as LeafNode<T>;\n      let s = sibling as LeafNode<T>;\n\n      // Steal an item.\n      c.items.unshift(s.items.pop()!);\n\n      // Update the branch items.\n      node.items[i] = c.items[0];\n\n      // Return the first modified index.\n      return i - 1;\n    }\n\n    // Join case #3: merge with next sibling leaf\n    if (isLeaf && !hasExtra && hasNext) {\n      // Cast the children as leaves.\n      let c = child as LeafNode<T>;\n      let s = sibling as LeafNode<T>;\n\n      // Merge items.\n      s.items.unshift(...c.items);\n\n      // Remove the old branch child.\n      ArrayExt.removeAt(node.children, i);\n\n      // Remove the stale branch item.\n      ArrayExt.removeAt(node.items, i + 1);\n\n      // Patch up the sibling links.\n      if (c.prev) c.prev.next = s;\n      s.prev = c.prev;\n\n      // Clear the original child.\n      clear(c);\n\n      // Return the first modified index.\n      return i;\n    }\n\n    // Join case #4: merge with previous sibling leaf\n    if (isLeaf && !hasExtra && !hasNext) {\n      // Cast the children as leaves.\n      let c = child as LeafNode<T>;\n      let s = sibling as LeafNode<T>;\n\n      // Merge items.\n      s.items.push(...c.items);\n\n      // Remove the old branch child.\n      ArrayExt.removeAt(node.children, i);\n\n      // Remove the stale branch item.\n      ArrayExt.removeAt(node.items, i);\n\n      // Patch up the sibling links.\n      if (c.next) c.next.prev = s;\n      s.next = c.next;\n\n      // Clear the original child.\n      clear(c);\n\n      // Return the first modified index.\n      return i - 1;\n    }\n\n    // Join case #5: steal from next sibling branch\n    if (!isLeaf && hasExtra && hasNext) {\n      // Cast the children to branches.\n      let c = child as BranchNode<T>;\n      let s = sibling as BranchNode<T>;\n\n      // Steal a child from the next sibling.\n      c.children.push(s.children.shift()!);\n\n      // Steal an item from the next sibling.\n      c.items.push(s.items.shift()!);\n\n      // Update the branch items.\n      node.items[i + 1] = s.items[0];\n\n      // Update the sibling sizes.\n      updateSizes(c, c.width - 1);\n      updateSizes(s, 0);\n\n      // Return the first modified index.\n      return i;\n    }\n\n    // Join case #6: steal from previous sibling branch\n    if (!isLeaf && hasExtra && !hasNext) {\n      // Cast the children to branches.\n      let c = child as BranchNode<T>;\n      let s = sibling as BranchNode<T>;\n\n      // Steal a child from the previous sibling.\n      c.children.unshift(s.children.pop()!);\n\n      // Steal an item from the previous sibling.\n      c.items.unshift(s.items.pop()!);\n\n      // Update the branch items.\n      node.items[i] = c.items[0];\n\n      // Update the sibling sizes.\n      updateSizes(c, 0);\n      updateSizes(s, s.width - 1);\n\n      // Return the first modified index.\n      return i - 1;\n    }\n\n    // Join case #7: merge with next sibling branch\n    if (!isLeaf && !hasExtra && hasNext) {\n      // Cast the children to branches.\n      let c = child as BranchNode<T>;\n      let s = sibling as BranchNode<T>;\n\n      // Merge the children with the next sibling.\n      s.children.unshift(...c.children);\n\n      // Merge the items with the next sibling.\n      s.items.unshift(...c.items);\n\n      // Remove the old branch child.\n      ArrayExt.removeAt(node.children, i);\n\n      // Remove the stale branch item.\n      ArrayExt.removeAt(node.items, i + 1);\n\n      // Update the sibling sizes.\n      updateSizes(s, 0);\n\n      // Clear the original child but, not its children.\n      c.children.length = 0;\n      clear(c);\n\n      // Return the first modified index.\n      return i;\n    }\n\n    // Join case #8: merge with previous sibling branch\n    if (!isLeaf && !hasExtra && !hasNext) {\n      // Cast the children to branches.\n      let c = child as BranchNode<T>;\n      let s = sibling as BranchNode<T>;\n\n      // Merge the children with the previous sibling.\n      s.children.push(...c.children);\n\n      // Merge the items with the previous sibling.\n      s.items.push(...c.items);\n\n      // Remove the old branch child.\n      ArrayExt.removeAt(node.children, i);\n\n      // Remove the stale branch item.\n      ArrayExt.removeAt(node.items, i);\n\n      // Update the sibling sizes.\n      updateSizes(s, 0);\n\n      // Clear the original child, but not its children.\n      c.children.length = 0;\n      clear(c);\n\n      // Return the first modified index.\n      return i - 1;\n    }\n\n    // One of the above cases must match.\n    throw 'unreachable';\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  IIterable, IIterator, IRetroable, IterableOrArrayLike, each\n} from '@lumino/algorithm';\n\n\n/**\n * A generic doubly-linked list.\n */\nexport\nclass LinkedList<T> implements IIterable<T>, IRetroable<T> {\n  /**\n   * Construct a new linked list.\n   */\n  constructor() { }\n\n  /**\n   * Whether the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get isEmpty(): boolean {\n    return this._size === 0;\n  }\n\n  /**\n   * The size of the list.\n   *\n   * #### Complexity\n   * `O(1)`\n   *\n   * #### Notes\n   * This is equivalent to `length`.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * The length of the list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `size`.\n   *\n   * This property is deprecated.\n   */\n  get length(): number {\n    return this._size;\n  }\n\n  /**\n   * The first value in the list.\n   *\n   * This is `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get first(): T | undefined {\n    return this._first ? this._first.value : undefined;\n  }\n\n  /**\n   * The last value in the list.\n   *\n   * This is `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get last(): T | undefined {\n    return this._last ? this._last.value : undefined;\n  }\n\n  /**\n   * The first node in the list.\n   *\n   * This is `null` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get firstNode(): LinkedList.INode<T> | null {\n    return this._first;\n  }\n\n  /**\n   * The last node in the list.\n   *\n   * This is `null` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get lastNode(): LinkedList.INode<T> | null {\n    return this._last;\n  }\n\n  /**\n   * Create an iterator over the values in the list.\n   *\n   * @returns A new iterator starting with the first value.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  iter(): IIterator<T> {\n    return new LinkedList.ForwardValueIterator<T>(this._first);\n  }\n\n  /**\n   * Create a reverse iterator over the values in the list.\n   *\n   * @returns A new iterator starting with the last value.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  retro(): IIterator<T> {\n    return new LinkedList.RetroValueIterator<T>(this._last);\n  }\n\n  /**\n   * Create an iterator over the nodes in the list.\n   *\n   * @returns A new iterator starting with the first node.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  nodes(): IIterator<LinkedList.INode<T>> {\n    return new LinkedList.ForwardNodeIterator<T>(this._first);\n  }\n\n  /**\n   * Create a reverse iterator over the nodes in the list.\n   *\n   * @returns A new iterator starting with the last node.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  retroNodes(): IIterator<LinkedList.INode<T>> {\n    return new LinkedList.RetroNodeIterator<T>(this._last);\n  }\n\n  /**\n   * Assign new values to the list, replacing all current values.\n   *\n   * @param values - The values to assign to the list.\n   *\n   * #### Complexity\n   * Linear.\n   */\n  assign(values: IterableOrArrayLike<T>): void {\n    this.clear();\n    each(values, value => { this.addLast(value); });\n  }\n\n  /**\n   * Add a value to the end of the list.\n   *\n   * @param value - The value to add to the end of the list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `addLast`.\n   */\n  push(value: T): void {\n    this.addLast(value);\n  }\n\n  /**\n   * Remove and return the value at the end of the list.\n   *\n   * @returns The removed value, or `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `removeLast`.\n   */\n  pop(): T | undefined {\n    return this.removeLast();\n  }\n\n  /**\n   * Add a value to the beginning of the list.\n   *\n   * @param value - The value to add to the beginning of the list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `addFirst`.\n   */\n  shift(value: T): void {\n    this.addFirst(value);\n  }\n\n  /**\n   * Remove and return the value at the beginning of the list.\n   *\n   * @returns The removed value, or `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `removeFirst`.\n   */\n  unshift(): T | undefined {\n    return this.removeFirst();\n  }\n\n  /**\n   * Add a value to the beginning of the list.\n   *\n   * @param value - The value to add to the beginning of the list.\n   *\n   * @returns The list node which holds the value.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  addFirst(value: T): LinkedList.INode<T> {\n    let node = new Private.LinkedListNode<T>(this, value);\n    if (!this._first) {\n      this._first = node;\n      this._last = node;\n    } else {\n      node.next = this._first;\n      this._first.prev = node;\n      this._first = node;\n    }\n    this._size++;\n    return node;\n  }\n\n  /**\n   * Add a value to the end of the list.\n   *\n   * @param value - The value to add to the end of the list.\n   *\n   * @returns The list node which holds the value.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  addLast(value: T): LinkedList.INode<T> {\n    let node = new Private.LinkedListNode<T>(this, value);\n    if (!this._last) {\n      this._first = node;\n      this._last = node;\n    } else {\n      node.prev = this._last;\n      this._last.next = node;\n      this._last = node;\n    }\n    this._size++;\n    return node;\n  }\n\n  /**\n   * Insert a value before a specific node in the list.\n   *\n   * @param value - The value to insert before the reference node.\n   *\n   * @param ref - The reference node of interest. If this is `null`,\n   *   the value will be added to the beginning of the list.\n   *\n   * @returns The list node which holds the value.\n   *\n   * #### Notes\n   * The reference node must be owned by the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  insertBefore(value: T, ref: LinkedList.INode<T> | null): LinkedList.INode<T> {\n    if (!ref || ref === this._first) {\n      return this.addFirst(value);\n    }\n    if (!(ref instanceof Private.LinkedListNode) || ref.list !== this) {\n      throw new Error('Reference node is not owned by the list.');\n    }\n    let node = new Private.LinkedListNode<T>(this, value);\n    let _ref = ref as Private.LinkedListNode<T>;\n    let prev = _ref.prev!;\n    node.next = _ref;\n    node.prev = prev;\n    _ref.prev = node;\n    prev.next = node;\n    this._size++;\n    return node;\n  }\n\n  /**\n   * Insert a value after a specific node in the list.\n   *\n   * @param value - The value to insert after the reference node.\n   *\n   * @param ref - The reference node of interest. If this is `null`,\n   *   the value will be added to the end of the list.\n   *\n   * @returns The list node which holds the value.\n   *\n   * #### Notes\n   * The reference node must be owned by the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  insertAfter(value: T, ref: LinkedList.INode<T> | null): LinkedList.INode<T> {\n    if (!ref || ref === this._last) {\n      return this.addLast(value);\n    }\n    if (!(ref instanceof Private.LinkedListNode) || ref.list !== this) {\n      throw new Error('Reference node is not owned by the list.');\n    }\n    let node = new Private.LinkedListNode<T>(this, value);\n    let _ref = ref as Private.LinkedListNode<T>;\n    let next = _ref.next!;\n    node.next = next;\n    node.prev = _ref;\n    _ref.next = node;\n    next.prev = node;\n    this._size++;\n    return node;\n  }\n\n  /**\n   * Remove and return the value at the beginning of the list.\n   *\n   * @returns The removed value, or `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  removeFirst(): T | undefined {\n    let node = this._first;\n    if (!node) {\n      return undefined;\n    }\n    if (node === this._last) {\n      this._first = null;\n      this._last = null;\n    } else {\n      this._first = node.next;\n      this._first!.prev = null;\n    }\n    node.list = null;\n    node.next = null;\n    node.prev = null;\n    this._size--;\n    return node.value;\n  }\n\n  /**\n   * Remove and return the value at the end of the list.\n   *\n   * @returns The removed value, or `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  removeLast(): T | undefined {\n    let node = this._last;\n    if (!node) {\n      return undefined;\n    }\n    if (node === this._first) {\n      this._first = null;\n      this._last = null;\n    } else {\n      this._last = node.prev;\n      this._last!.next = null;\n    }\n    node.list = null;\n    node.next = null;\n    node.prev = null;\n    this._size--;\n    return node.value;\n  }\n\n  /**\n   * Remove a specific node from the list.\n   *\n   * @param node - The node to remove from the list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * The node must be owned by the list.\n   */\n  removeNode(node: LinkedList.INode<T>): void {\n    if (!(node instanceof Private.LinkedListNode) || node.list !== this) {\n      throw new Error('Node is not owned by the list.');\n    }\n    let _node = node as Private.LinkedListNode<T>;\n    if (_node === this._first && _node === this._last) {\n      this._first = null;\n      this._last = null;\n    } else if (_node === this._first) {\n      this._first = _node.next;\n      this._first!.prev = null;\n    } else if (_node === this._last) {\n      this._last = _node.prev;\n      this._last!.next = null;\n    } else {\n      _node.next!.prev = _node.prev;\n      _node.prev!.next = _node.next;\n    }\n    _node.list = null;\n    _node.next = null;\n    _node.prev = null;\n    this._size--;\n  }\n\n  /**\n   * Remove all values from the list.\n   *\n   * #### Complexity\n   * Linear.\n   */\n  clear(): void {\n    let node = this._first;\n    while (node) {\n      let next = node.next;\n      node.list = null;\n      node.prev = null;\n      node.next = null;\n      node = next;\n    }\n    this._first = null;\n    this._last = null;\n    this._size = 0;\n  }\n\n  private _first: Private.LinkedListNode<T> | null = null;\n  private _last: Private.LinkedListNode<T> | null = null;\n  private _size = 0;\n}\n\n\n/**\n * The namespace for the `LinkedList` class statics.\n */\nexport\nnamespace LinkedList {\n  /**\n   * An object which represents a node in a linked list.\n   *\n   * #### Notes\n   * User code will not create linked list nodes directly. Nodes\n   * are created automatically when values are added to a list.\n   */\n  export\n  interface INode<T> {\n    /**\n     * The linked list which created and owns the node.\n     *\n     * This will be `null` when the node is removed from the list.\n     */\n    readonly list: LinkedList<T> | null;\n\n    /**\n     * The next node in the list.\n     *\n     * This will be `null` when the node is the last node in the list\n     * or when the node is removed from the list.\n     */\n    readonly next: INode<T> | null;\n\n    /**\n     * The previous node in the list.\n     *\n     * This will be `null` when the node is the first node in the list\n     * or when the node is removed from the list.\n     */\n    readonly prev: INode<T> | null;\n\n    /**\n     * The user value stored in the node.\n     */\n    readonly value: T;\n  }\n\n  /**\n   * Create a linked list from an iterable of values.\n   *\n   * @param values - The iterable or array-like object of interest.\n   *\n   * @returns A new linked list initialized with the given values.\n   *\n   * #### Complexity\n   * Linear.\n   */\n  export\n  function from<T>(values: IterableOrArrayLike<T>): LinkedList<T> {\n    let list = new LinkedList<T>();\n    list.assign(values);\n    return list;\n  }\n\n  /**\n   * A forward iterator for values in a linked list.\n   */\n  export\n  class ForwardValueIterator<T> implements IIterator<T> {\n    /**\n     * Construct a forward value iterator.\n     *\n     * @param node - The first node in the list.\n     */\n    constructor(node: INode<T> | null) {\n      this._node = node;\n    }\n\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    iter(): IIterator<T> {\n      return this;\n    }\n\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    clone(): IIterator<T> {\n      return new ForwardValueIterator<T>(this._node);\n    }\n\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    next(): T | undefined {\n      if (!this._node) {\n        return undefined;\n      }\n      let node = this._node;\n      this._node = node.next;\n      return node.value;\n    }\n\n    private _node: INode<T> | null;\n  }\n\n  /**\n   * A reverse iterator for values in a linked list.\n   */\n  export\n  class RetroValueIterator<T> implements IIterator<T> {\n    /**\n     * Construct a retro value iterator.\n     *\n     * @param node - The last node in the list.\n     */\n    constructor(node: INode<T> | null) {\n      this._node = node;\n    }\n\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    iter(): IIterator<T> {\n      return this;\n    }\n\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    clone(): IIterator<T> {\n      return new RetroValueIterator<T>(this._node);\n    }\n\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    next(): T | undefined {\n      if (!this._node) {\n        return undefined;\n      }\n      let node = this._node;\n      this._node = node.prev;\n      return node.value;\n    }\n\n    private _node: INode<T> | null;\n  }\n\n  /**\n   * A forward iterator for nodes in a linked list.\n   */\n  export\n  class ForwardNodeIterator<T> implements IIterator<INode<T>> {\n    /**\n     * Construct a forward node iterator.\n     *\n     * @param node - The first node in the list.\n     */\n    constructor(node: INode<T> | null) {\n      this._node = node;\n    }\n\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    iter(): IIterator<INode<T>> {\n      return this;\n    }\n\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    clone(): IIterator<INode<T>> {\n      return new ForwardNodeIterator<T>(this._node);\n    }\n\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    next(): INode<T> | undefined {\n      if (!this._node) {\n        return undefined;\n      }\n      let node = this._node;\n      this._node = node.next;\n      return node;\n    }\n\n    private _node: INode<T> | null;\n  }\n\n  /**\n   * A reverse iterator for nodes in a linked list.\n   */\n  export\n  class RetroNodeIterator<T> implements IIterator<INode<T>> {\n    /**\n     * Construct a retro node iterator.\n     *\n     * @param node - The last node in the list.\n     */\n    constructor(node: INode<T> | null) {\n      this._node = node;\n    }\n\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    iter(): IIterator<INode<T>> {\n      return this;\n    }\n\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    clone(): IIterator<INode<T>> {\n      return new RetroNodeIterator<T>(this._node);\n    }\n\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    next(): INode<T> | undefined {\n      if (!this._node) {\n        return undefined;\n      }\n      let node = this._node;\n      this._node = node.prev;\n      return node;\n    }\n\n    private _node: INode<T> | null;\n  }\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The internal linked list node implementation.\n   */\n  export\n  class LinkedListNode<T> {\n    /**\n     * The linked list which created and owns the node.\n     */\n    list: LinkedList<T> | null = null;\n\n    /**\n     * The next node in the list.\n     */\n    next: LinkedListNode<T> | null = null;\n\n    /**\n     * The previous node in the list.\n     */\n    prev: LinkedListNode<T> | null = null;\n\n    /**\n     * The user value stored in the node.\n     */\n    readonly value: T;\n\n    /**\n     * Construct a new linked list node.\n     *\n     * @param list - The list which owns the node.\n     *\n     * @param value - The value for the link.\n     */\n    constructor(list: LinkedList<T>, value: T) {\n      this.list = list;\n      this.value = value;\n    }\n  }\n}\n"]}